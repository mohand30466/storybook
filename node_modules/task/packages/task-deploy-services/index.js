const { isAbsolute, join } = require('path')
const { exec } = require('child_process')
const fs = require('fs')
const cache = {}

const absolute = (path, cwd) => isAbsolute(path) ? path : join(cwd, path)

const envVar = string => {
  var i = 0
  string = string.toUpperCase().replace(/[^a-zA-Z0-9_]/g, '_')
  while (string[i] === '_') i++
  return string.slice(i)
}

const merge = (a, b) => {
  if (typeof a !== 'object') return b
  const obj = {}
  for (let i in b) {
    obj[i] = merge(a[i], b[i])
  }
  for (let i in a) {
    if (!(i in obj) && i !== 'package' && i !== 'targets') {
      obj[i] = a[i]
    }
  }
  return obj
}

const collect = ({ name, services }, store, cwd, dependent) => {
  if (!name) throw new Error(`no name defined in package.json: ${cwd}`)
  const service = store[name] || (store[name] = {
    name,
    env: envVar(name),
    url: {},
    cwd,
    services: []
  })

  if (dependent) dependent.services.push(service)
  else service.isEntry = true

  return Promise.all(Object.keys(services || {}).map(key => {
    const dir = absolute(services[key], cwd)
    const path = join(dir, 'package.json')
    return cache[path] || (cache[path] = new Promise((resolve, reject) => {
      fs.readFile(path, (err, data) => {
        if (err) reject(err)
        else resolve(collect(JSON.parse(data), store, dir, service))
      })
    }))
  }))
}

const deployNow = (service, cmd, gaurd) => {
  if (gaurd[service.name]) {
    console.log('😡 allready deploying', service.name)
    return
  }
  console.log('☄️☄️☄️ DEPLOY', service.name)
  gaurd[service.name] = exec(cmd, { cwd: service.cwd })
  return gaurd[service.name]
}

const deploy = (services, opts, gaurd) => Promise.all(services.map(service => {
  const { name, env } = opts
  if (!(name in service.url)) {
    if (service.services.every(({ url }) => name in url)) {
      return new Promise((resolve, reject) => {
        var cmd = service.services.reduce(
          (cmd, { env, url }) => cmd + ` -e ${env}=${url[name]}`,
          'now --forward-npm -e PORT=80')
        for (let i in env) {
          cmd += ` -e ${i}=${env[i]}`
        }

        const child = deployNow(service, cmd, gaurd)
        if (!child) {
          resolve()
        } else {
          child.stderr.on('data', err => {
            reject(Error(`error deploying ${service.name}: ${err.stack}`))
          })
          child.stdout.on('data', function grabUrl (data) {
            const [ url ] = /https?:\/\/.+\.[a-z]{1,20}/.exec(data)
            if (url) {
              service.url[name] = url
              child.stdout.removeListener('data', grabUrl)
              // elegant until you run into the same service and start to deploy it multiple times
              resolve(deploy(services, opts, gaurd))
            }
          })
        }
      })
    }
  }
}))

const options = (task, cwd) => {
  const opts = Object.assign({
    targets: [{ name: 'default' }]
  }, task.get('options', {}).serialize(true))

  if (!opts.package) { // make this async
    opts.package = fs.readFileSync(join(cwd, 'package.json')).toString()
  }

  if (typeof opts.package === 'string') {
    opts.package = JSON.parse(opts.package)
  }

  if (!Array.isArray(opts.targets)) {
    opts.targets = Object.keys(opts.targets).map(name => {
      const target = opts.targets[name]
      if (!('name' in target)) target.name = name
      return target
    })
  }

  opts.targets = opts.targets.map((target, i) => Object.assign({
    name: i,
    env: {}
  }, merge(opts, target)))

  return opts
}

exports.types = {
  'deploy-services': (task, hub, cwd) => new Promise((resolve, reject) => {
    const { targets, package: pkg } = options(task, cwd)
    const store = {}
    const gaurd = {}
    collect(pkg, store, cwd).then(() => {
      const services = Object.keys(store)
        .map(name => store[name])
        .filter(service => !service.isEntry)

      return Promise.all(targets.map(opts => deploy(services, opts, gaurd))).then(() => {
        const services = store[pkg.name].services
        if (services) {
          services.forEach(({ url, env: envName }) => {
            targets.forEach(({ name, env }) => { env[envName] = url[name] })
          })
        }
        resolve({
          result: targets,
          done: true
        })
      })
    })
  })
}
