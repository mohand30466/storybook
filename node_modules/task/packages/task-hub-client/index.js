const resolve = require('rollup-plugin-node-resolve')
const commonjs = require('rollup-plugin-commonjs')
const buble = require('rollup-plugin-buble')
const rollup = require('rollup')
const fs = require('fs')
const { join } = require('path')
const { hostname } = require('os')
const { lookup } = require('dns')

const createReloadSubscription = reload => {
  const tasks = {}
  reload.forEach(taskname => (tasks[taskname.compute()] = { done: true }))
  return JSON.stringify({ tasks })
}

const getUrl = hub => new Promise(resolve => lookup(hostname(), (e, ip) => {
  resolve(`ws://${ip}:${hub.port.compute()}`)
}))

const hubSubscribe = options => {
  const reload = options.get('reload')
  if (reload.val) {
    const fn = reload.val.toString()
    return fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))
  } else {
    const reloadSubscription = createReloadSubscription(options.get('reload', {}))
    return `console.log('💫 livereload', ${reloadSubscription})
      const start = bs.create()
      hub.subscribe({ error: true }, s => {
        if (s.compute()) console.log('❗', s.compute())
      })
      hub.subscribe(${reloadSubscription}, s => {
        console.log('reload?', s.compute())
        if (s.compute() > start) {
          console.log('💫 go reload! 💫')
          global.location.reload()
        }
      })`
  }
}

const write = (entry, options, hub) => {
  const code = hubSubscribe(options)
  return getUrl(hub).then(url => new Promise(resolve => fs.writeFile(entry,
   `import h from 'hub.js'
    import bs from 'stamp'
    console.log('💫 hub-client 💫')
    const hub = h({ url: '${url}' })
    ${code}`.replace(/\n {4}/g, '\n'), resolve)))
}

const bundle = (entry, cache) => rollup.rollup({
  entry,
  cache,
  plugins: [ resolve({ browser: true }), commonjs(), buble() ]
}).catch((err) => console.log(err))
/*
  options:
  - reload
  result: client hub code (iife)
*/
exports.types = {
  'hub-client': {
    val (task, hub, cwd) {
      const entry = join(cwd, `.${task.path().join('.')}.js`)
      const cache = task.get('cache')
      return write(entry, task.get('options', {}), hub)
      .then(() => bundle(entry, cache))
      .then(bundle => {
        fs.unlink(entry, err => err && hub.emit('error', err))
        return {
          result: bundle.generate({
            intro: 'var global = window;',
            format: 'iife'
          }).code,
          done: true
        }
      })
    },
    props: {
      cache: true
    }
  }
}
