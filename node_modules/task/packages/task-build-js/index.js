const { isAbsolute, dirname, join } = require('path')
const buildboy = require('builder-boy')
const fs = require('fs')
const getAbsolutePath = (path, cwd) => isAbsolute(path) ? path : join(cwd, path)

const write = (dest, content) => new Promise((resolve, reject) => {
  console.log('write!')
  const path = dirname(dest).split('/')
  var dir = ''
  path.forEach(part => {
    if (!fs.existsSync(dir += `/${part}`)) fs.mkdirSync(dir)
  })
  fs.writeFile(dest, content, err => {
    if (err) reject(err)
    else resolve()
  })
})
/*
  options:
  - entry: entry point (required)
  - dest: optional
*/

const findEntry = (entries, cwd, index = 0) => new Promise((resolve, reject) => {
  const entry = entries[index]
  if (!entry) return reject(Error(`task-build-js: failed to find entry ${entries}`))
  const file = getAbsolutePath(entry, cwd)
  fs.stat(file, err => {
    resolve(err ? findEntry(entries, cwd, index + 1) : file)
  })
})

// builder boy passon
exports.types = {
  'build-js': (task, hub, cwd) => {
    const opts = task.get('options', {})
    var entry = opts.get('entry', false).serialize()
    var dest = opts.get(['dest', 'compute'])
    var build = opts.get('builder')
    build = build ? build.val : buildboy

    if (!entry) return Promise.reject('no entry')
    if (!Array.isArray(entry)) entry = [ entry ]
    return findEntry(entry, cwd).then(entry => {
      if (dest) dest = getAbsolutePath(dest, cwd)
      fs.realpath(entry, (err, real) => {
        if (err) {
          throw err
        } else {
          const options = opts.serialize(true)
          if (options.env) {
            options.env = opts.get('env', {}).compute().serialize(true)
          }
          if (!options.verbose) {
            options.verbose = false
          }
          build(real, options, (err, result) => {
            if (err) {
              throw err
            } else {
              if (dest) {
                task.set({ result })
                Promise.all([
                  result.node && write(dest, result.node),
                  result.inline && write(dest.replace(/.js$/, '.inline.js'), result.inline),
                  result.browser && write(dest.replace(/.js$/, '.browser.js'), result.browser)
                ])
                .then(() => task.set({ done: true }))
              } else {
                task.set({
                  result,
                  done: true
                })
              }
            }
          })
        }
      })
    })
  }
}
