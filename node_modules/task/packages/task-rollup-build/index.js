const rollup = require('rollup')
const { isAbsolute, join } = require('path')
const getAbsolutePath = (path, cwd) => isAbsolute(path) ? path : join(cwd, path)
/*
  options:
  - entry: entry point (required)
  - all options that rollup supports*: https://github.com/rollup/rollup/wiki/JavaScript-API
  result:
  - [format]: { // cjs, es or iife (default is es)
      code: generated code,
      sourceMap: sourcemap if sourceMap option is true
    }
*/
exports.types = {
  'rollup-build': {
    val (task, hub, cwd) {
      const opts = task.get('options', {})
      const options = opts.serialize((t, result) => {
        if (typeof result === 'function') return result
        const computed = t.compute()
        return computed !== void 0 && typeof computed !== 'object' ? computed : result
      })

      options.cache = opts.cache
      options.entry = getAbsolutePath(options.entry, cwd)

      return rollup.rollup(options).then(bundle => {
        const targets = options.targets
          ? options.targets.map(opts => Object.assign({}, options, opts))
          : [ options ]
        const result = {}
        const generateResult = opts => {
          const { code, map } = bundle.generate(options)
          result[opts.format] = map ? {
            sourceMap: map.toString(),
            code
          } : { code }
          if (opts.dest) {
            opts.dest = getAbsolutePath(opts.dest, cwd)
            return bundle.write(opts)
          }
        }

        const returnResult = () => ({
          options: { cache: bundle },
          result,
          done: true
        })
        return Promise.all(targets.map(generateResult)).then(returnResult)
      })
    },
    options: {
      format: 'es',
      props: {
        cache: true
      }
    }
  }
}
