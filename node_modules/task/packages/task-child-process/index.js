const { exec } = require('child_process')
const findPort = require('../../src/util/find-port')
const getIP = require('../../src/util/get-ip')
const ports = {}
/*
options:
- cmd: string (required)
- debug: true or port nr
- all options of exec
result:
- childProcess
- log
*/
const getPort = (start, d = 1) => {
  while (start) {
    if (!(start in ports)) {
      ports[start] = true
      return new Promise(resolve => {
        findPort(start).then(port => {
          if (start !== port && start in ports) delete ports[start]
          resolve(port)
        })
      })
    }
    start += d
  }
}

exports.types = {
  'child-process': {
    val: (task, hub, cwd) => new Promise(resolve => {
      const hostname = task.get(['options', 'hostname'], false)
      const listens = task.get(['options', 'listens'], false)
      const debug = task.get(['options', 'debug'], false)

      if (debug.compute() === true) debug.set(getPort(60000))
      if (!hostname.compute()) hostname.set(getIP())
      if (!listens.compute()) listens.set(getPort(1023))

      const execTask = () => {
        const options = Object.assign(
          { cwd, stdio: 'inherit' },
          task.get('options', {}).serialize(true)
        )
        options.env = Object.assign({}, process.env, {
          HOST: `${options.hostname}:${options.listens}`,
          PORT: options.listens
        }, options.env)

        if (options.debug) {
          options.cmd = options.cmd.replace(/(^node)\b/, `node --inspect --debug=${options.debug}`)
        }

        options.env.PLOY_TASK_HUB = `ws://${options.hostname}:${hub.port.compute()}`

        const child = exec(options.cmd, options)
        const onexit = () => child.kill()
        const ondata = data => task.get('log', {}).push(data)

        child.stdout.on('data', ondata)
        child.stderr.on('data', ondata)
        child.on('uncaughtException', err => hub.emit('error', err))
        child.on('close', () => {
          process.removeListener('exit', onexit)
          task.set({
            result: { child: null },
            done: true
          })
        })
        process.on('exit', onexit)
        process.on('SIGINT', onexit)

        task.set({ result: { child } })
      }

      const child = task.get(['result', 'child'])
      if (child) {
        child.on('close', () => {
          const current = task.get(['result', 'child'])
          if (!current || current === child) execTask()
        })
        child.kill()
      } else {
        debug.once(val => typeof (val.compute() || 0) === 'number').then(() => {
          listens.once(val => val.compute()).then(execTask)
        })
      }
    }),
    props: {
      result: {
        props: {
          child: true
        },
        on: (val, stamp, { child }) => val === null && child && child.kill()
      }
    }
  }
}
